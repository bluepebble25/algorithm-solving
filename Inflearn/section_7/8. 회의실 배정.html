<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      /*
        그리디적인 접근방법으로 세 가지를 생각해볼 수 있다.
        1) 회의 시간이 짧은 순으로 정렬
        2) 일찍 시작하는 순으로
        3) 일찍 끝나는 순으로

        그런데 일찍 시작한다고 회의가 더 빨리 끝나는 것은 아니고 시간을 많이 잡아먹으면 손해이므로
        1) 회의 시간이 짧은 순으로
        2) 일찍 끝나는 순으로
        만 고려해보도록 하자.

        근데 회의 시간이 짧아도 중간에 배치되어 있는 회의라면 남은 시간을 블록처럼 잘게 쪼개게 되어 다른 회의가 들어갈 기회를 박탈하게 된다.
        그리고 일찍 끝나는 순으로 배치하면 남은 시간 블록(단일 조각 1개)의 길이가 더 길어지게 된다.

        답은 <끝나는 시간이 이른 순으로> 정렬을 하는 것이다.
        끝나는 시간을 변수에 저장하고 그 다음 회의의 시작 시간이 end보다 크거나 같으면 배정한다.
        근데 고려해야 할 조건이 하나 더 있다. (시작시간<=끝나는 시간)에서 "시작시간과 끝나는 시간이 같은 경우"를 고려해보자.
        [[3, 3], [1, 3], [2, 3]]이 있을 때 어떻게 알고리즘을 짜야할까?
        (1,3)(3,3) / (2,3)(3,3) 중 가능한 것은 (1,3)(3,3)이다. 왜냐하면 시작 시간이 늦은 순서대로 정렬하고 선택하면 (3,3)밖에 선택이 안되기 때문이다.
        따라서 끝나는 시간이 같다면 시작 시간이 이른 순으로 정렬해야 한다.

        정리> 끝나는 시간이 이른 순으로 정렬하고 끝나는 시간이 같다면 시작 시간이 이른 순으로 정렬
              다음 요소의 시작 시간이 이전 회의의 끝나는 시간보다 같거나 크면 배정
              
      */
      function solution(arr) {
        let count = 1;
        arr.sort((a, b) => {
          if (a[1] === b[1]) return a[0] - b[0];
          return a[1] - b[1];
        });

        let end = arr[0][1];

        arr.forEach((m) => {
          if (end <= m[0]) {
            end = m[1];
            count++;
          }
        });

        return count;
      }

      // let arr = [
      //   [3, 3],
      //   [1, 3],
      //   [2, 3],
      // ];
      let arr = [
        [1, 4],
        [2, 3],
        [3, 5],
        [4, 6],
        [5, 7],
      ];
      console.log(solution(arr));
    </script>
  </body>
</html>
